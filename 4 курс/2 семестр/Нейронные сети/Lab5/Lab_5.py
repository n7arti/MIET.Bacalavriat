import numpy as np
import matplotlib.pyplot as plt

zero = [-1, +1, +1, +1, +1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, +1, +1, +1, +1, -1]
zero = np.asarray(zero).T
one = [-1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, +1, +1, -1,
       -1, -1, -1, +1, -1, +1, -1,
       -1, -1, +1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1]
one = np.asarray(one).T
two = [-1, +1, +1, +1, +1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, +1, -1, -1,
       -1, -1, -1, +1, -1, -1, -1,
       -1, -1, +1, -1, -1, -1, -1,
       -1, +1, +1, +1, +1, +1, -1]
two = np.asarray(two).T
three = [-1, +1, +1, +1, +1, +1, -1,
         -1, -1, -1, -1, +1, -1, -1,
         -1, -1, -1, +1, -1, -1, -1,
         -1, -1, +1, -1, -1, -1, -1,
         -1, +1, +1, +1, +1, +1, -1,
         -1, -1, -1, -1, +1, -1, -1,
         -1, -1, -1, +1, -1, -1, -1,
         -1, -1, +1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1]
three = np.asarray(three).T
four = [-1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, +1, +1, +1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1]
four = np.asarray(four).T
five = [-1, +1, +1, +1, +1, +1, -1,
        -1, +1, -1, -1, -1, -1, -1,
        -1, +1, -1, -1, -1, -1, -1,
        -1, +1, -1, -1, -1, -1, -1,
        -1, +1, +1, +1, +1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, -1, -1, -1, -1, +1, -1,
        -1, +1, +1, +1, +1, +1, -1]
five = np.asarray(five).T
six = [-1, -1, -1, -1, -1, +1, -1,
       -1, -1, -1, -1, +1, -1, -1,
       -1, -1, -1, +1, -1, -1, -1,
       -1, -1, +1, -1, -1, -1, -1,
       -1, +1, +1, +1, +1, +1, -1,
       -1, +1, -1, -1, -1, +1, -1,
       -1, +1, -1, -1, -1, +1, -1,
       -1, +1, -1, -1, -1, +1, -1,
       -1, +1, +1, +1, +1, +1, -1]
six = np.asarray(six).T
seven = [-1, +1, +1, +1, +1, +1, -1,
         -1, -1, -1, -1, +1, -1, -1,
         -1, -1, -1, +1, -1, -1, -1,
         -1, -1, +1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1,
         -1, +1, -1, -1, -1, -1, -1]
seven = np.asarray(seven).T
eight = [-1, +1, +1, +1, +1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, +1, +1, +1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, -1, -1, -1, +1, -1,
         -1, +1, +1, +1, +1, +1, -1]
eight = np.asarray(eight).T
nine = [-1, +1, +1, +1, +1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, -1, -1, -1, +1, -1,
        -1, +1, +1, +1, +1, +1, -1,
        -1, -1, -1, -1, +1, -1, -1,
        -1, -1, -1, +1, -1, -1, -1,
        -1, -1, +1, -1, -1, -1, -1,
        -1, +1, -1, -1, -1, -1, -1]
nine = np.asarray(nine).T
my_digits = np.asarray([zero, one, two, three, four, five, six, seven, eight, nine])


def f_54(x, n, w):
    y = [x * w]
    for l in range(n):
        y.append(w * y[-1])
    return y


plt.plot(range(11), f_54(1, 10, 0.1))
plt.grid()
plt.title('|w| < 1')
plt.show()


def hopfield_weights_1(N, x):
    sz1, sz2 = x.shape
    if sz1 < N:
        ones = np.ones((sz2, N - sz1))
        ones = [-i for i in ones]
        x = np.append(ones, x, axis=0)
    W = x.T * x
    for i in range(N):
        W[i, i] = 0
    return W


def hopfield_weights_2(N, x):
    x = x.T
    sz1, sz2 = x.shape
    if sz1 > N / (2 * np.log(N)) or N < sz2:
        print('Сеть с таким количеством нейронов не способна запомнить данные образцы')
        W = -1
    else:
        if (sz2 < N):
            x = np.append(np.ones((sz1, N - sz2)), x)
        W = x.T * x
        for i in range(N):
            W[i, i] = 0
    return W


x = np.asarray([[1], [-1], [1], [-1]])
N = 4
print(hopfield_weights_1(N, x))

x = np.asarray([[1], [-1], [1]])
N = 3
print(hopfield_weights_2(N, x))


def train_hop_net(digits):
    """
     Настройка нейронной сети Хопфилда.
     Весовые значения для сети Хопфилда определяются непосресдственно в процессе
     обработки обучающих данных минуя проведение обучения в более привычном
     смысле (сопоставлением "вход-выход").
     Переменная digits = {four five six} - список образцов фундаментальной
     памяти
     Переменная weights определяет матрицу весовых коэффициентов нейронной сети Хопфилда
     (ассоциативной памяти)
    """
    n = len(digits)
    m = len(digits[0])
    arr = np.ndarray((n, m))
    for i in range(n):
        for j in range(m):
            arr[i, j] = digits[i][j]
    return np.dot(arr.T, arr)


def test_hop_net(weights, digit, iterations):
    """
    Тестирование нейронной сети Хопфилда
    Переменная weights описывает весовые коэффициенты рекуррентной сети с сохраненными элементами фундаментальной памяти
    Переменная digit - входной образ (может представлять собой и зашумленную версию исходного вектора)
    Переменная iterations - число "эпох" тестирования, имея в виду под эпохой
    полное обновление состояния каждого из нейронов в случайном порядке
    """

    new_digit = np.asarray(digit).copy()

    for epoch in range(iterations):
        update_order = np.random.permutation(range(63))
        # Обновление состояния нейронов в случайном порядке
        for i in range(63):
            neuron = update_order[i]
            net = np.dot(new_digit, weights[:, neuron])
            new_digit[neuron] = np.sign(net)
    return new_digit


def noisy_digit(digit, noise):
    """
    Создание зашумлённой версии входного образа
    Переменная digit задаёт входной образ из фундаментальной памяти или произвольный образ
    Переменная noise определяет уровень шума, добавляемого к исходному вектору
    """
    if noise < 0 or noise > 1:
        print('Уровень шума должен быть в пределах от 0 до 1\n')
    return digit + np.random.uniform(-noise, noise, np.asarray(digit).size)


def visualize_number(num):
    if type(num) != np.ndarray:
        num = np.asarray(num)
    plt.imshow(num.reshape(9, 7), cmap='Greys')
    plt.show()


w1 = train_hop_net([zero])
w = train_hop_net([zero, one])
visualize_number(test_hop_net(w, zero, 1))
visualize_number(test_hop_net(w, one, 1))

mass = np.asarray([my_digits[0], my_digits[1]])
w = train_hop_net(mass)
visualize_number(test_hop_net(w, noisy_digit(my_digits[2], 0.3), 1))
visualize_number(test_hop_net(w, noisy_digit(my_digits[3], 0.3), 1))
